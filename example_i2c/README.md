# STM32H7 I2C Example

This example project demonstrates I2C communication on the STM32H723 microcontroller using the Lumos build tool.

## Overview

This project initializes I2C1 to communicate with I2C devices at 100kHz standard speed. It demonstrates:

- **System clock configuration** - Configures the H7 to run at 550 MHz
- **I2C initialization** - Sets up I2C1 with GPIO pins
- **I2C bus scanning** - Scans for devices on the bus
- **I2C read/write functions** - Read and write registers on I2C devices
- **Example sensor reading** - Reads temperature from LM75-compatible sensors

## Hardware Requirements

### STM32H7 Board
- **MCU**: STM32H723VG (or compatible H7 variant)
- **Clock**: 25 MHz external crystal (HSE)
- **I2C Pins**:
  - PB6 - I2C1_SCL (clock)
  - PB7 - I2C1_SDA (data)

### I2C Pull-up Resistors
I2C requires pull-up resistors on both SCL and SDA lines. Most development boards have these built-in (typically 4.7kΩ), but if not:
- Add 4.7kΩ resistor from SCL to 3.3V
- Add 4.7kΩ resistor from SDA to 3.3V

### I2C Devices
This example will work with any I2C device. Common examples:
- **Temperature sensors**: LM75, TMP100, MCP9808
- **EEPROM**: AT24C32, 24LC256
- **RTC**: DS1307, DS3231
- **I/O expanders**: PCF8574, MCP23017
- **Sensors**: BME280, BMP180, Si7021

## Project Configuration

The `project.yaml` file is simple:

```yaml
sources:
  - src/main.c
  - src/i2c_config.c

hal_modules:
  - i2c

board: LumosBrain
```

The Lumos build tool automatically includes all necessary HAL drivers.

## Building

From the `example_i2c` directory, run:

```bash
lumos build
```

Or using the full path:

```bash
/path/to/LumosTool/build/src/applications/lumos_simple/lumos_simple build
```

### Build Output

The build will create:
- `build/firmware.elf` - ELF file with debug symbols
- `build/firmware.bin` - Raw binary for flashing
- `build/firmware.map` - Memory map file

Expected binary size: ~7.5 KB

## Flashing

Flash the firmware to your STM32H7 board using ST-Link or another programmer:

### Using ST-Link

```bash
st-flash write build/firmware.bin 0x8000000
```

### Using OpenOCD

```bash
openocd -f interface/stlink.cfg -f target/stm32h7x.cfg \
  -c "program build/firmware.elf verify reset exit"
```

### Using STM32CubeProgrammer

1. Open STM32CubeProgrammer
2. Connect to your board
3. Load `build/firmware.bin`
4. Set address to `0x08000000`
5. Click "Start Programming"

## Hardware Connections

### I2C Pins

```
STM32H7          I2C Device
-------          ----------
PB6 (SCL)   -->  SCL
PB7 (SDA)   <->  SDA
GND         -->  GND
3.3V        -->  VCC (if device is 3.3V)
```

**Important**:
- Ensure I2C device voltage matches (3.3V for most STM32 boards)
- If device is 5V, use level shifters
- Connect pull-up resistors if not present on breakout board

### Example: Connecting LM75 Temperature Sensor

```
STM32H7          LM75
-------          ----
PB6 (SCL)   -->  SCL
PB7 (SDA)   <->  SDA
GND         -->  GND
3.3V        -->  VCC
             -->  A0, A1, A2 to GND (address = 0x48)
```

## Code Structure

### Files

```
example_i2c/
├── README.md                    # This file
├── project.yaml                 # Build configuration
├── include/
│   └── i2c_config.h            # I2C configuration defines
├── src/
│   ├── main.c                  # Main application
│   └── i2c_config.c            # I2C and clock init
└── build/                      # Generated by build (output)
```

### Key Functions

**i2c_config.c:SystemClock_Config()**
- Configures PLL for 550 MHz operation
- Sets up voltage scaling for high performance
- Configures bus clock dividers

**i2c_config.c:I2C_Init()**
- Enables GPIOB and I2C1 clocks
- Configures PB6 and PB7 as open-drain with pull-ups
- Initializes I2C1 to 100kHz, 7-bit addressing
- Configures analog and digital filters

**i2c_config.c:I2C_ScanBus()**
- Scans all 7-bit addresses (0x03 to 0x77)
- Returns array of found device addresses
- Uses `HAL_I2C_IsDeviceReady()` to detect devices

**i2c_config.c:I2C_WriteReg()**
- Writes a single byte to a register
- Parameters: device address, register address, data

**i2c_config.c:I2C_ReadReg()**
- Reads a single byte from a register
- Parameters: device address, register address, pointer to data

**i2c_config.c:I2C_ReadMulti()**
- Reads multiple bytes from a register
- Parameters: device address, register address, data buffer, length

**main.c:main()**
- Initializes HAL library
- Configures system clock to 550 MHz
- Initializes I2C
- Scans I2C bus every second
- If LM75 sensor found at 0x48, reads temperature

## I2C Configuration

### Speed: 100kHz (Standard Mode)

The I2C timing register is configured for 100kHz at 550MHz CPU clock:

```c
#define I2C_TIMING    0x60404E72
```

This value was calculated for STM32H7 running at 550MHz with the following parameters:
- I2C Clock: 100 kHz
- Rise time: 100ns
- Fall time: 10ns

### Other Speeds

For **400kHz (Fast Mode)**, use:
```c
#define I2C_TIMING    0x40604E72
```

For **1MHz (Fast Mode Plus)**, use:
```c
#define I2C_TIMING    0x00702991
```

**Note**: Higher speeds may require shorter wires and better signal integrity.

## Customization

### Change I2C Instance

To use a different I2C peripheral (e.g., I2C2):

1. Edit `include/i2c_config.h`:
   ```c
   #define I2C_INSTANCE            I2C2
   #define I2C_SCL_GPIO_PORT       GPIOF  // Check datasheet for pins
   #define I2C_SCL_PIN             GPIO_PIN_1
   #define I2C_SCL_AF              GPIO_AF4_I2C2
   // ... update SDA pin similarly
   ```

2. Edit `src/i2c_config.c`:
   - Update clock enable from `__HAL_RCC_I2C1_CLK_ENABLE()` to `__HAL_RCC_I2C2_CLK_ENABLE()`
   - Update handle from `hi2c1` to `hi2c2`

3. Rebuild with `lumos build`

### Add More I2C Devices

To communicate with different I2C devices, use the provided functions:

```c
// Example: Read from BME280 sensor at address 0x76
uint8_t chip_id;
I2C_ReadReg(0x76, 0xD0, &chip_id);  // Read chip ID register

// Example: Write to EEPROM at address 0x50
I2C_WriteReg(0x50, 0x00, 0xAA);  // Write 0xAA to address 0x00

// Example: Read 6 bytes from sensor
uint8_t data[6];
I2C_ReadMulti(0x76, 0xF7, data, 6);
```

### Add UART Output

To see scan results and sensor readings, combine with the UART example:

1. Add UART initialization from `example_uart`
2. Add `uart` to `hal_modules` in `project.yaml`:
   ```yaml
   hal_modules:
     - i2c
     - uart
   ```
3. Output I2C scan results to UART:
   ```c
   for (uint8_t i = 0; i < device_count; i++) {
       sprintf(msg, "Found device at 0x%02X\r\n", found_devices[i]);
       UART_SendString(msg);
   }
   ```

## Troubleshooting

### No devices found on I2C bus

1. **Check connections**: Verify SCL and SDA are connected correctly
2. **Check pull-ups**: Measure voltage on SCL/SDA - should be ~3.3V when idle
3. **Check device power**: Ensure I2C device has power (VCC connected)
4. **Check device address**: Verify the device's I2C address (check datasheet or A0/A1/A2 pins)
5. **Check signal integrity**: Use oscilloscope to verify clock and data signals

### Build fails

1. **Check Lumos root**: Make sure the build tool can find the LumosTool directory
2. **Check toolchain**: Ensure ARM GCC toolchain exists in `src/toolchains/`
3. **Check HAL modules**: Verify `i2c` is listed in `project.yaml`

### I2C communication errors

1. **HAL_BUSY**: I2C peripheral is busy - add delay between transactions
2. **HAL_TIMEOUT**: Device not responding - check connections and address
3. **HAL_ERROR**: Bus error - check for short circuits, missing pull-ups

### Wrong data from sensor

1. **Check register addresses**: Verify register map in device datasheet
2. **Check data format**: Some sensors use MSB first, others LSB first
3. **Check initialization**: Some sensors require configuration before reading

## Technical Details

### Memory Usage

- **Flash**: ~7.5 KB (out of 1 MB available)
- **RAM**: Minimal static allocation
  - Stack: Defined in linker script
  - Heap: Not used in this example

### Clock Configuration

- **HSE**: 25 MHz (external crystal)
- **PLL VCO**: 1100 MHz (25 MHz / 5 * 220)
- **SYSCLK**: 550 MHz (VCO / 2)
- **HCLK**: 275 MHz (SYSCLK / 2)
- **APB1**: 137.5 MHz (HCLK / 2) - I2C1 clock source

### I2C Timing Calculation

The I2C timing value is calculated based on:
- **APB1 clock**: 137.5 MHz
- **Target I2C speed**: 100 kHz
- **Rise time**: 100 ns
- **Fall time**: 10 ns

Use STM32CubeMX or the timing calculator in the reference manual to compute timing values for different speeds or CPU frequencies.

## Common I2C Device Addresses

| Device | Address (7-bit) | Description |
|--------|-----------------|-------------|
| LM75, TMP100 | 0x48-0x4F | Temperature sensors |
| BME280 | 0x76, 0x77 | Temp/Humidity/Pressure |
| BMP180/280 | 0x76, 0x77 | Barometric pressure |
| MPU6050 | 0x68, 0x69 | Gyro/Accelerometer |
| DS1307 | 0x68 | Real-time clock |
| DS3231 | 0x68 | Precision RTC |
| AT24C32 | 0x50-0x57 | EEPROM |
| PCF8574 | 0x20-0x27 | I/O expander |
| SSD1306 | 0x3C, 0x3D | OLED display |

## Next Steps

Now that you have I2C working, you can:

1. **Add specific sensor drivers** - Create drivers for BME280, MPU6050, etc.
2. **Add UART for debugging** - Output I2C scan results and sensor data
3. **Add DMA** - Use DMA for efficient I2C transfers
4. **Add error recovery** - Implement bus recovery for stuck conditions
5. **Add multiple devices** - Communicate with several I2C devices
6. **Add interrupts** - Use I2C interrupts instead of polling

## References

- [STM32H723 Datasheet](https://www.st.com/resource/en/datasheet/stm32h723vg.pdf)
- [STM32H723 Reference Manual](https://www.st.com/resource/en/reference_manual/rm0468-stm32h723733-stm32h725735-and-stm32h730-value-line-advanced-armbased-32bit-mcus-stmicroelectronics.pdf)
- [STM32H7 HAL User Manual](https://www.st.com/resource/en/user_manual/dm00392525-description-of-stm32h7-hal-and-lowlayer-drivers-stmicroelectronics.pdf)
- [I2C Specification](https://www.nxp.com/docs/en/user-guide/UM10204.pdf) - NXP I2C-bus specification

## License

This example is provided as-is for demonstration purposes.
