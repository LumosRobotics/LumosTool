# STM32H7 SD Card Example (SPI Mode)

This example project demonstrates SD card initialization and reading/writing using SPI mode on the STM32H723 microcontroller using the Lumos build tool.

## Overview

This project initializes an SD card in SPI mode and demonstrates:

- **SD card initialization** - Auto-detects SD Ver 1.x, Ver 2.0 (SDSC), and SDHC cards
- **Block reading** - Read 512-byte blocks from SD card
- **Block writing** - Write 512-byte blocks to SD card
- **MBR reading** - Read Master Boot Record / Partition Table
- **Speed optimization** - Starts at 400 kHz for init, switches to ~8.6 MHz for data transfer

## Hardware Requirements

### STM32H7 Board
- **MCU**: STM32H723VG (or compatible H7 variant)
- **Clock**: 25 MHz external crystal (HSE)
- **SPI Pins**:
  - PA5 - SPI1_SCK (clock)
  - PA6 - SPI1_MISO (master in, slave out)
  - PA7 - SPI1_MOSI (master out, slave in)
  - PA4 - CS (chip select, software controlled)

### SD Card Module
You can use:
- **Micro SD Card Breakout Module** - Most common, has level shifters and voltage regulator
- **SD Card Adapter** - Standard SD to microSD adapter
- **Direct Connection** - If using 3.3V SD card

## Project Configuration

The `project.yaml` file is simple:

```yaml
sources:
  - src/main.c
  - src/sdcard.c
  - src/spi_config.c

hal_modules:
  - spi

board: LumosBrain
```

The Lumos build tool automatically includes all necessary HAL drivers.

## Building

From the `example_sdcard` directory, run:

```bash
lumos build
```

Or using the full path:

```bash
/path/to/LumosTool/build/src/applications/lumos_simple/lumos_simple build
```

### Build Output

The build will create:
- `build/firmware.elf` - ELF file with debug symbols
- `build/firmware.bin` - Raw binary for flashing
- `build/firmware.map` - Memory map file

Expected binary size: ~13 KB

## Flashing

Flash the firmware to your STM32H7 board using ST-Link or another programmer:

### Using ST-Link

```bash
st-flash write build/firmware.bin 0x8000000
```

### Using OpenOCD

```bash
openocd -f interface/stlink.cfg -f target/stm32h7x.cfg \
  -c "program build/firmware.elf verify reset exit"
```

### Using STM32CubeProgrammer

1. Open STM32CubeProgrammer
2. Connect to your board
3. Load `build/firmware.bin`
4. Set address to `0x08000000`
5. Click "Start Programming"

## Hardware Connections

### SPI Pins

```
STM32H7          SD Card Module
-------          --------------
PA5 (SCK)   -->  SCK/CLK
PA6 (MISO)  <--  MISO/DO/DAT0
PA7 (MOSI)  -->  MOSI/DI/CMD
PA4 (CS)    -->  CS/SS/DAT3
GND         -->  GND
3.3V        -->  VCC
```

**Important Notes**:
- Most SD card modules have built-in voltage regulators and level shifters
- If connecting directly, ensure SD card is 3.3V compatible
- Keep wires as short as possible for reliable communication
- CS (Chip Select) is active LOW - pulled high when idle

### SD Card Pinout

**Micro SD Card (SPI mode)**:
```
      ┌─────┐
      │  1  │ DAT2 (not used in SPI mode)
      │  2  │ CS/DAT3
      │  3  │ MOSI/CMD
      │  4  │ VCC (3.3V)
      │  5  │ CLK
      │  6  │ GND
      │  7  │ MISO/DAT0
      │  8  │ DAT1 (not used in SPI mode)
      └─────┘
```

**Standard SD Card (SPI mode)**:
```
Pin 1: DAT3/CS
Pin 2: CMD/MOSI
Pin 3: GND
Pin 4: VCC (3.3V)
Pin 5: CLK
Pin 6: GND
Pin 7: DAT0/MISO
Pin 8: DAT1 (not used in SPI mode)
Pin 9: DAT2 (not used in SPI mode)
```

## Code Structure

### Files

```
example_sdcard/
├── README.md                    # This file
├── project.yaml                 # Build configuration
├── include/
│   ├── spi_config.h            # SPI configuration defines
│   └── sdcard.h                # SD card driver interface
├── src/
│   ├── main.c                  # Main application
│   ├── sdcard.c                # SD card driver implementation
│   └── spi_config.c            # SPI and clock init
└── build/                      # Generated by build (output)
```

### Key Functions

**spi_config.c:SystemClock_Config()**
- Configures PLL for 550 MHz operation
- Sets up voltage scaling for high performance
- Configures bus clock dividers

**spi_config.c:SPI_Init()**
- Starts at low speed (400 kHz) for SD card initialization
- Configures SPI1 in Mode 0 (CPOL=0, CPHA=0)
- Speed increased to ~8.6 MHz after initialization

**sdcard.c:SDCard_Init()**
- Sends power-up sequence (74+ clock pulses)
- Sends CMD0 to enter SPI mode
- Sends CMD8 to detect SD Ver 2.0 cards
- Sends ACMD41 to initialize card
- Detects card type (V1, V2/SDSC, SDHC)
- Increases SPI speed after successful init

**sdcard.c:SDCard_ReadBlock()**
- Reads 512-byte block from SD card
- Handles both SDSC (byte addressing) and SDHC (block addressing)
- Waits for data token (0xFE)
- Reads 512 bytes + 2-byte CRC

**sdcard.c:SDCard_WriteBlock()**
- Writes 512-byte block to SD card
- Sends data token (0xFE)
- Writes 512 bytes + 2-byte CRC
- Waits for write completion

## SD Card Initialization Sequence

1. **Power-up**: Send 74+ clock pulses with CS high
2. **CMD0**: Reset card and enter SPI mode (expect R1: 0x01)
3. **CMD8**: Check if card is SD Ver 2.0 (send 0x1AA voltage and pattern)
4. **ACMD41**: Initialize card (repeat until R1: 0x00)
   - For Ver 2.0: Set HCS bit (0x40000000) to support SDHC
5. **CMD58**: Read OCR to determine if SDHC (check CCS bit)
6. **CMD16**: Set block size to 512 (only for SDSC cards)
7. **Increase Speed**: Switch from 400 kHz to faster speed (up to 25 MHz)

## SD Card Types

### SD Ver 1.x (SDSC)
- Capacity: Up to 2 GB
- Addressing: Byte addressing (address = block_number × 512)
- Must set block size with CMD16

### SD Ver 2.0 (SDSC)
- Capacity: Up to 2 GB
- Addressing: Byte addressing
- Supports CMD8 voltage check

### SD Ver 2.0 (SDHC)
- Capacity: 4 GB to 32 GB
- Addressing: Block addressing (address = block_number)
- CCS bit set in OCR register

## SPI Configuration

### Initial Speed: ~537 kHz
During initialization (required by SD card specification):
```
SPI Clock = APB2 Clock / Prescaler
          = 137.5 MHz / 256
          = 537 kHz
```

### Data Transfer Speed: ~8.6 MHz
After successful initialization:
```
SPI Clock = APB2 Clock / Prescaler
          = 137.5 MHz / 16
          = 8.6 MHz
```

### Maximum Speed
SD cards in SPI mode can operate up to 25 MHz. You can increase speed by changing:
```c
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;  // ~17 MHz
// or
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;  // ~34 MHz (may not work)
```

### SPI Mode: Mode 0
- **CPOL = 0**: Clock idle low
- **CPHA = 0**: Data sampled on rising edge

## Memory Usage

- **Flash**: ~13 KB (out of 1 MB available)
- **RAM**: Minimal static allocation
  - Stack: Defined in linker script
  - Heap: Not used in this example

## Usage Examples

### Example 1: Read Master Boot Record

```c
uint8_t mbr[512];
if (SDCard_ReadBlock(0, mbr) == SDCARD_OK) {
    // Check boot signature (bytes 510-511 should be 0x55AA)
    if (mbr[510] == 0x55 && mbr[511] == 0xAA) {
        // Valid MBR
        // Partition table starts at offset 0x1BE
    }
}
```

### Example 2: Write and Verify Data

```c
uint8_t write_data[512];
uint8_t read_data[512];

// Fill with test pattern
for (int i = 0; i < 512; i++) {
    write_data[i] = i & 0xFF;
}

// Write to block 1000
if (SDCard_WriteBlock(1000, write_data) == SDCARD_OK) {
    // Read back
    if (SDCard_ReadBlock(1000, read_data) == SDCARD_OK) {
        // Verify
        if (memcmp(write_data, read_data, 512) == 0) {
            // Success!
        }
    }
}
```

### Example 3: Read FAT Filesystem

```c
// Read MBR
uint8_t mbr[512];
SDCard_ReadBlock(0, mbr);

// Get first partition start (offset 0x1C6, little-endian)
uint32_t partition_start = mbr[0x1C6] |
                           (mbr[0x1C7] << 8) |
                           (mbr[0x1C8] << 16) |
                           (mbr[0x1C9] << 24);

// Read first sector of partition (boot sector)
uint8_t boot_sector[512];
SDCard_ReadBlock(partition_start, boot_sector);

// Parse FAT boot sector
// Bytes 11-12: Bytes per sector (should be 512)
// Bytes 13: Sectors per cluster
// etc.
```

## Troubleshooting

### Card Not Detected (Init Error)

1. **Check connections**: Verify all SPI pins are connected correctly
2. **Check CS polarity**: CS should be HIGH when idle, LOW during transfer
3. **Check power**: Ensure card has stable 3.3V power
4. **Check speed**: Try lower SPI speed during init (prescaler 256)
5. **Add pullup resistors**: Some modules need 10k pullups on MISO

### Init Timeout

1. **Check card compatibility**: Some old/unusual cards may not work
2. **Try different card**: Test with known-good SD card
3. **Increase timeout**: Modify timeout values in `SDCard_Init()`
4. **Check wiring**: Long wires can cause signal integrity issues

### Read/Write Errors

1. **Check addressing**: SDHC uses block addressing, SDSC uses byte addressing
2. **Check card write-protection**: Some cards have physical write-protect switch
3. **Verify card format**: Card should be formatted as FAT16 or FAT32
4. **Check SPI speed**: May need to reduce speed for reliable operation

### Wrong Data Read

1. **Check SPI mode**: Verify CPOL=0, CPHA=0 (Mode 0)
2. **Check bit order**: Should be MSB first
3. **Verify block address**: Make sure addressing is correct for card type
4. **Check for bus errors**: Use logic analyzer to verify SPI signals

## Customization

### Use Different SPI Instance

To use SPI2 or SPI3:

1. Edit `include/spi_config.h`:
   ```c
   #define SPI_INSTANCE            SPI2
   // Update pin definitions (check datasheet)
   #define SPI_SCK_GPIO_PORT       GPIOB
   #define SPI_SCK_PIN             GPIO_PIN_13
   // ... etc
   ```

2. Edit `src/spi_config.c`:
   - Update clock enable from `__HAL_RCC_SPI1_CLK_ENABLE()` to `__HAL_RCC_SPI2_CLK_ENABLE()`
   - Update handle from `hspi1` to `hspi2`

3. Rebuild with `lumos build`

### Increase SPI Speed

After initialization, you can increase speed:

```c
// In sdcard.c:SDCard_Init(), change:
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;  // ~17 MHz
HAL_SPI_Init(&hspi1);
```

### Add UART Debugging

1. Add UART example files to project
2. Add `uart` to `hal_modules` in project.yaml
3. Print SD card info:
   ```c
   printf("SD Card Type: %s\r\n", SDCard_TypeToString(sd_type));
   ```

## FAT Filesystem Support

This example provides low-level SD card access. For filesystem support:

1. **Use FatFs**: Integrate Chan's FatFs library
2. **Mount filesystem**: `f_mount(&fs, "", 0)`
3. **Open files**: `f_open(&file, "test.txt", FA_READ)`
4. **Read/Write**: `f_read()`, `f_write()`

FatFs provides a complete FAT16/FAT32/exFAT implementation.

## Limitations

- **SPI mode only**: Does not use native SD 4-bit mode (slower but simpler)
- **Polling mode**: No DMA or interrupt support (can be added)
- **Single block**: No multi-block read/write (can be added with CMD18/CMD25)
- **No CRC checking**: CRC is read but not verified
- **No card detect**: Assumes card is always present

## Next Steps

Now that you have SD card working, you can:

1. **Add FatFs** - Implement complete filesystem support
2. **Add data logging** - Log sensor data to SD card
3. **Add configuration files** - Read config from SD card on startup
4. **Add firmware updates** - Load new firmware from SD card
5. **Add DMA** - Use DMA for faster transfers
6. **Add multi-block** - Implement CMD18/CMD25 for faster bulk transfers

## References

- [SD Card Physical Layer Specification](https://www.sdcard.org/downloads/pls/)
- [STM32H723 Datasheet](https://www.st.com/resource/en/datasheet/stm32h723vg.pdf)
- [STM32H723 Reference Manual](https://www.st.com/resource/en/reference_manual/rm0468-stm32h723733-stm32h725735-and-stm32h730-value-line-advanced-armbased-32bit-mcus-stmicroelectronics.pdf)
- [FatFs Generic FAT Filesystem Module](http://elm-chan.org/fsw/ff/00index_e.html)

## License

This example is provided as-is for demonstration purposes.
