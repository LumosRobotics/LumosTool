# STM32H7 SPI Example

This example project demonstrates SPI communication on the STM32H723 microcontroller using the Lumos build tool.

## Overview

This project initializes SPI1 to communicate with SPI devices at ~2 MHz. It demonstrates:

- **System clock configuration** - Configures the H7 to run at 550 MHz
- **SPI initialization** - Sets up SPI1 in master mode with GPIO pins
- **SPI communication** - Transmit, receive, and full-duplex operations
- **Flash memory example** - Reads JEDEC ID from W25Q series flash chips

## Hardware Requirements

### STM32H7 Board
- **MCU**: STM32H723VG (or compatible H7 variant)
- **Clock**: 25 MHz external crystal (HSE)
- **SPI Pins**:
  - PA5 - SPI1_SCK (clock)
  - PA6 - SPI1_MISO (master in, slave out)
  - PA7 - SPI1_MOSI (master out, slave in)
  - PA4 - CS (chip select, software controlled)

### SPI Devices
This example will work with any SPI device. Common examples:
- **Flash memory**: W25Q16, W25Q32, W25Q64, W25Q128
- **SD cards**: With SPI mode support
- **EEPROM**: 25LC256, AT25256
- **Sensors**: BME280, MPU6050 (SPI mode), MAX31855
- **Displays**: ST7735, ILI9341, SSD1306 (SPI mode)
- **ADC/DAC**: MCP3008, MCP4921

## Project Configuration

The `project.yaml` file is simple:

```yaml
sources:
  - src/main.c
  - src/spi_config.c

hal_modules:
  - spi

board: LumosBrain
```

The Lumos build tool automatically includes all necessary HAL drivers.

## Building

From the `example_spi` directory, run:

```bash
lumos build
```

Or using the full path:

```bash
/path/to/LumosTool/build/src/applications/lumos_simple/lumos_simple build
```

### Build Output

The build will create:
- `build/firmware.elf` - ELF file with debug symbols
- `build/firmware.bin` - Raw binary for flashing
- `build/firmware.map` - Memory map file

Expected binary size: ~8.5 KB

## Flashing

Flash the firmware to your STM32H7 board using ST-Link or another programmer:

### Using ST-Link

```bash
st-flash write build/firmware.bin 0x8000000
```

### Using OpenOCD

```bash
openocd -f interface/stlink.cfg -f target/stm32h7x.cfg \
  -c "program build/firmware.elf verify reset exit"
```

### Using STM32CubeProgrammer

1. Open STM32CubeProgrammer
2. Connect to your board
3. Load `build/firmware.bin`
4. Set address to `0x08000000`
5. Click "Start Programming"

## Hardware Connections

### SPI Pins

```
STM32H7          SPI Device
-------          ----------
PA5 (SCK)   -->  SCK/CLK
PA6 (MISO)  <--  MISO/SDO
PA7 (MOSI)  -->  MOSI/SDI
PA4 (CS)    -->  CS/SS
GND         -->  GND
3.3V        -->  VCC (if device is 3.3V)
```

**Important**:
- SPI devices can have different voltage levels (check datasheet)
- Some 5V devices need level shifters
- Keep wires short for reliable high-speed communication
- CS (Chip Select) is active LOW - pulled high when idle

### Example: Connecting W25Q Flash Memory

```
STM32H7          W25Q16/32/64
-------          ------------
PA5 (SCK)   -->  CLK (pin 6)
PA6 (MISO)  <--  DO (pin 2)
PA7 (MOSI)  -->  DI (pin 5)
PA4 (CS)    -->  CS (pin 1)
GND         -->  GND (pin 4)
3.3V        -->  VCC (pin 8)
             -->  WP (pin 3) to VCC
             -->  HOLD (pin 7) to VCC
```

## Code Structure

### Files

```
example_spi/
├── README.md                    # This file
├── project.yaml                 # Build configuration
├── include/
│   └── spi_config.h            # SPI configuration defines
├── src/
│   ├── main.c                  # Main application with flash demo
│   └── spi_config.c            # SPI and clock init
└── build/                      # Generated by build (output)
```

### Key Functions

**spi_config.c:SystemClock_Config()**
- Configures PLL for 550 MHz operation
- Sets up voltage scaling for high performance
- Configures bus clock dividers

**spi_config.c:SPI_Init()**
- Enables GPIOA and SPI1 clocks
- Configures PA5/PA6/PA7 as SPI alternate function pins
- Configures PA4 as CS (chip select) output
- Initializes SPI1 to ~2 MHz, Mode 0 (CPOL=0, CPHA=0)

**spi_config.c:SPI_Transmit()**
- Sends data over SPI
- Parameters: data buffer, size

**spi_config.c:SPI_Receive()**
- Receives data over SPI
- Parameters: receive buffer, size

**spi_config.c:SPI_TransmitReceive()**
- Full-duplex SPI communication
- Parameters: TX buffer, RX buffer, size

**spi_config.c:SPI_TransferByte()**
- Transfer a single byte (TX and RX)
- Returns received byte

**main.c:Flash_ReadJEDEC_ID()**
- Reads manufacturer ID, device type, and capacity from flash
- Standard command supported by most SPI flash chips

**main.c:Flash_ReadStatus()**
- Reads status register from flash
- Used to check busy flag and write protection

**main.c:Flash_ReadData()**
- Reads data from a specific address in flash memory
- Example of typical SPI flash operation

## SPI Configuration

### Speed: ~2 MHz

The SPI clock is configured with a prescaler of 64:
```
SPI Clock = APB2 Clock / Prescaler
          = 137.5 MHz / 64
          = 2.15 MHz
```

### SPI Mode: Mode 0

- **CPOL = 0**: Clock idle low
- **CPHA = 0**: Data sampled on rising edge

This is the most common SPI mode, but some devices use different modes:
- **Mode 1**: CPOL=0, CPHA=1
- **Mode 2**: CPOL=1, CPHA=0
- **Mode 3**: CPOL=1, CPHA=1

### Available Prescalers

For different speeds, change `BaudRatePrescaler`:

| Prescaler | Speed | Use Case |
|-----------|-------|----------|
| `SPI_BAUDRATEPRESCALER_2` | ~68 MHz | Very high speed (short wires) |
| `SPI_BAUDRATEPRESCALER_4` | ~34 MHz | High speed |
| `SPI_BAUDRATEPRESCALER_8` | ~17 MHz | Fast devices |
| `SPI_BAUDRATEPRESCALER_16` | ~8.6 MHz | Standard speed |
| `SPI_BAUDRATEPRESCALER_32` | ~4.3 MHz | Most devices |
| `SPI_BAUDRATEPRESCALER_64` | ~2.2 MHz | **Default** |
| `SPI_BAUDRATEPRESCALER_128` | ~1.1 MHz | Slow devices, long wires |
| `SPI_BAUDRATEPRESCALER_256` | ~537 kHz | Very slow, debugging |

## Customization

### Change SPI Speed

Edit `src/spi_config.c`:

```c
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_32;  // ~4.3 MHz
```

### Change SPI Mode

Edit `src/spi_config.c`:

```c
// For Mode 3 (CPOL=1, CPHA=1)
hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;     // CPOL = 1
hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;          // CPHA = 1
```

### Use Different SPI Instance

To use SPI2 or SPI3:

1. Edit `include/spi_config.h`:
   ```c
   #define SPI_INSTANCE            SPI2
   // Update pin definitions (check datasheet)
   #define SPI_SCK_GPIO_PORT       GPIOB
   #define SPI_SCK_PIN             GPIO_PIN_13
   // ... etc
   ```

2. Edit `src/spi_config.c`:
   - Update clock enable from `__HAL_RCC_SPI1_CLK_ENABLE()` to `__HAL_RCC_SPI2_CLK_ENABLE()`
   - Update handle from `hspi1` to `hspi2`

3. Rebuild with `lumos build`

### Add Multiple CS Pins

For multiple SPI devices on the same bus:

1. Add more CS pin definitions in `spi_config.h`:
   ```c
   #define SPI_CS2_GPIO_PORT       GPIOB
   #define SPI_CS2_PIN             GPIO_PIN_0

   #define SPI_CS2_LOW()           HAL_GPIO_WritePin(SPI_CS2_GPIO_PORT, SPI_CS2_PIN, GPIO_PIN_RESET)
   #define SPI_CS2_HIGH()          HAL_GPIO_WritePin(SPI_CS2_GPIO_PORT, SPI_CS2_PIN, GPIO_PIN_SET)
   ```

2. Initialize the CS pin in `SPI_Init()`:
   ```c
   GPIO_InitStruct.Pin = SPI_CS2_PIN;
   GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   HAL_GPIO_Init(SPI_CS2_GPIO_PORT, &GPIO_InitStruct);
   SPI_CS2_HIGH();
   ```

3. Use different CS pins for different devices

## Common SPI Devices

### W25Q Flash Memory

The example code works with W25Q series flash chips:

```c
Flash_ReadJEDEC_ID(&manufacturer, &device_type, &capacity);
// manufacturer = 0xEF (Winbond)
// device_type = 0x40 (W25Q series)
// capacity: 0x14=1MB, 0x15=2MB, 0x16=4MB, 0x17=8MB, 0x18=16MB
```

### SD Card (SPI Mode)

SD cards support SPI mode with these commands:
- CMD0: GO_IDLE_STATE
- CMD8: SEND_IF_COND
- CMD17: READ_SINGLE_BLOCK
- CMD24: WRITE_BLOCK

### BME280 Sensor (SPI Mode)

Read temperature/humidity/pressure:
```c
SPI_CS_LOW();
uint8_t reg = 0xD0;  // Chip ID register
SPI_Transmit(&reg, 1);
uint8_t id;
SPI_Receive(&id, 1);  // Should read 0x60
SPI_CS_HIGH();
```

### MAX31855 Thermocouple

Read temperature:
```c
SPI_CS_LOW();
uint8_t data[4];
SPI_Receive(data, 4);
SPI_CS_HIGH();
// Parse temperature from 4 bytes
```

## Troubleshooting

### No response from SPI device

1. **Check connections**: Verify all SPI pins are connected correctly
2. **Check CS polarity**: CS should be HIGH when idle, LOW during transfer
3. **Check power**: Ensure device has power (VCC connected)
4. **Check voltage levels**: Some devices are 5V, may need level shifters
5. **Check SPI mode**: Verify CPOL/CPHA match device requirements

### Wrong data received

1. **Check SPI mode**: CPOL and CPHA must match device
2. **Check bit order**: Some devices use LSB first (uncommon)
3. **Check timing**: May need slower clock speed
4. **Check command format**: Verify command bytes match datasheet

### Build fails

1. **Check Lumos root**: Make sure the build tool can find the LumosTool directory
2. **Check toolchain**: Ensure ARM GCC toolchain exists in `src/toolchains/`
3. **Check HAL modules**: Verify `spi` is listed in `project.yaml`

### SPI communication errors

1. **HAL_BUSY**: SPI peripheral is busy - add delay between transactions
2. **HAL_TIMEOUT**: No clock detected - check SCK connection
3. **HAL_ERROR**: Bus error - check for short circuits

## Technical Details

### Memory Usage

- **Flash**: ~8.5 KB (out of 1 MB available)
- **RAM**: Minimal static allocation
  - Stack: Defined in linker script
  - Heap: Not used in this example

### Clock Configuration

- **HSE**: 25 MHz (external crystal)
- **PLL VCO**: 1100 MHz (25 MHz / 5 * 220)
- **SYSCLK**: 550 MHz (VCO / 2)
- **HCLK**: 275 MHz (SYSCLK / 2)
- **APB2**: 137.5 MHz (HCLK / 2) - SPI1 clock source

### SPI Timing

At 2 MHz SPI clock:
- **Bit time**: 500 ns
- **Byte time**: 4 µs
- **1 KB transfer**: ~4 ms

At maximum speed (~68 MHz):
- **Bit time**: ~15 ns
- **Byte time**: ~120 ns
- **1 KB transfer**: ~120 µs

## Waveform Analysis

Use a logic analyzer or oscilloscope to verify SPI signals:

**Expected waveforms**:
1. **CS**: Goes LOW, stays LOW during transfer, goes HIGH
2. **SCK**: Square wave with configured frequency
3. **MOSI**: Data changes on falling edge (Mode 0)
4. **MISO**: Data sampled on rising edge (Mode 0)

## Next Steps

Now that you have SPI working, you can:

1. **Add specific device drivers** - Create drivers for SD cards, displays, sensors
2. **Add DMA** - Use DMA for efficient large data transfers
3. **Add UART for debugging** - Output SPI data to serial console
4. **Add multiple devices** - Use different CS pins for multiple devices
5. **Add interrupt mode** - Use SPI interrupts instead of polling
6. **Increase speed** - Optimize for high-speed transfers

## Example: Reading from SD Card

```c
// Initialize SD card in SPI mode
void SD_Init(void)
{
    // Send CMD0: GO_IDLE_STATE
    SPI_CS_LOW();
    uint8_t cmd[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95};
    SPI_Transmit(cmd, 6);
    // Wait for response...
    SPI_CS_HIGH();
}
```

## References

- [STM32H723 Datasheet](https://www.st.com/resource/en/datasheet/stm32h723vg.pdf)
- [STM32H723 Reference Manual](https://www.st.com/resource/en/reference_manual/rm0468-stm32h723733-stm32h725735-and-stm32h730-value-line-advanced-armbased-32bit-mcus-stmicroelectronics.pdf)
- [STM32H7 HAL User Manual](https://www.st.com/resource/en/user_manual/dm00392525-description-of-stm32h7-hal-and-lowlayer-drivers-stmicroelectronics.pdf)
- [W25Q Flash Datasheet](https://www.winbond.com/resource-files/w25q32jv%20revg%2003272018%20plus.pdf)

## License

This example is provided as-is for demonstration purposes.
